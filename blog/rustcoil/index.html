<!DOCTYPE html>

<html lang="en">
<head>
	<meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta http-equiv="content-type" content="text/html; charset=utf-8">

    <!-- Enable responsiveness on mobile devices-->
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1">
    
<link rel="stylesheet" href="https://zengor.github.io/article.css">


    <title>
    	
			
				Rustcoil Engine
			
    	
    </title>


<body>
	
<main>
	<article>
		
	    <header>
	    	
	    	<div class="pageTitle">
	    		Rustcoil Engine 
	    	</div>
	    	<div class="metaInfo">
	    		
	    		
	    	</div>
			<nav><a href="../"> ‚ÜêBack to aaa</a></nav>
	    </header>
		
		<div class="articleContent">
			<p>Rustcoil is an <a href="https://en.wikipedia.org/wiki/Magic:_The_Gathering">MTG</a> simulator engine written in Rust. Despite being very simple to learn, the <a href="https://www.yawgatog.com/resources/magic-rules/">MTG rules</a> are very complex in a really interesting way, which made me want to model them in code.</p>
<p>The <code>GameObj</code> trait represents a single object as defined within the MTG rules (not to be confused with a rust object). A <code>GameObj</code> does not have to know everything about its state, as a lot of effects modifying it should not be reflected in the object itself. </p>
<pre data-lang="rust" class="language-rust "><code class="language-rust" data-lang="rust">trait GameObj {
	fn data(&amp;self) -&gt; ObjData;
}
</code></pre>
<p><code>ObJData</code> is a view into an object's characteristics, status, etc. It's returned by a GameObj and is then modified by the engine to apply static and continuous abilities</p>
<pre data-lang="rust" class="language-rust "><code class="language-rust" data-lang="rust">struct ObjData {
	&#x2F;&#x2F; a bunch of stuff
}
</code></pre>
<p>An <code>Ability</code> is something that can apply to a GameObj or to a player. An <code>Ability</code> is not a <code>GameObj</code> itself, but when an activated or triggered ability goes on the stack, a <code>GameObj</code> is created for it.</p>
<pre data-lang="rust" class="language-rust "><code class="language-rust" data-lang="rust">trait Ability {
	&#x2F;&#x2F;&#x2F; defines which zones the ability applies in
	fn is_active_in(zone: &amp;Zone) -&gt; bool;
	&#x2F;&#x2F;&#x2F; creates the changes this abilities creates
	fn apply(&amp;self, ctx: &amp;GameCtx) -&gt; Vec&lt;Box&lt;dyn UnitChange&gt;&gt;;
	&#x2F;&#x2F;&#x2F; returns the id of the object that gave origin to this ability
	fn source(&amp;self) -&gt; EntityId;
}
</code></pre>
<pre data-lang="rust" class="language-rust "><code class="language-rust" data-lang="rust">trait TriggeredAbility {
	&#x2F;&#x2F;&#x2F; The collection of game events this ability is listening for
	fn hooks(&amp;self) -&gt; Vec&lt;TriggerEvent&gt;;
	&#x2F;&#x2F;&#x2F; Checks for additional conditions and determines whether 
	fn triggers(&amp;mut self, event: TriggerEvent, ctx: GameCtx) -&gt; bool;
}
</code></pre>
<pre data-lang="rust" class="language-rust "><code class="language-rust" data-lang="rust">enum TriggerEvent {
	&#x2F;&#x2F;&#x2F; a custom check of the game state not defined by the above;
	State(Box&lt;dyn fn(&amp;GameCtx) -&gt; bool&gt;),
}
</code></pre>
<pre data-lang="rust" class="language-rust "><code class="language-rust" data-lang="rust">trait StaticAbility {
	&#x2F;&#x2F;&#x2F; defines which zones the ability applies in
	fn is_active_in(zone: &amp;Zone) -&gt; bool;
}
</code></pre>
<p><code>Abilities</code> is a container for all of an objects abilities. Each kind is tracked </p>
<pre data-lang="rust" class="language-rust "><code class="language-rust" data-lang="rust">enum Ability {
	SpellAbility(Box&lt;dyn SpellAbility&gt;),
	Activated(Box&lt;dyn ActivatedAbility&gt;),
	Triggered(Box&lt;dyn TriggeredAbility&gt;),
	Static(Box&lt;dyn StaticAbility&gt;),
}
</code></pre>
<pre data-lang="rust" class="language-rust "><code class="language-rust" data-lang="rust">trait UnitChange {
	type Result;
	fn apply(self, &amp;mut ctx) -&gt; Self::Result;
}
</code></pre>
<pre data-lang="rust" class="language-rust "><code class="language-rust" data-lang="rust">&#x2F;&#x2F; how to handle deathtouch, etc?
struct MarkDamage(usize, EntityId);

struct AddMana(Mana, PlayerId);

struct CreateObject(GameObj, Zone, PlayerId);

struct DestroyObject(GameObj);

enum Discard {
	SelectAndDiscard {
		selecting_player: PlayerId,
		discarding_player: PlayerId,
		query: ObjQuery,
	},
	AllOf(ObjQuery, PlayerId),
	Random(PlayerId),
}
</code></pre>
<pre data-lang="rust" class="language-rust "><code class="language-rust" data-lang="rust">struct Rustcoil {
	ctx: GameCtx,
	stateMachine: StateMachine,
	
}
</code></pre>

		</div>
	</article>
</main>

</body>


</head>
</html>